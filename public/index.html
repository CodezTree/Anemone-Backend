<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Animon</title>
        <style>
            /* Ïä§ÌÉÄÏùº Î∂ÄÎ∂ÑÏùÄ Í∏∞Ï°¥Í≥º ÎèôÏùºÌï©ÎãàÎã§. */
            body {
                font-family: Arial, sans-serif;
                background-color: #f0f8ff;
                color: #333;
                display: flex;
                flex-direction: column;
                align-items: center;
                margin: 0;
                padding: 0;
                height: 100vh;
                justify-content: center;
            }

            h1 {
                margin-bottom: 10px;
                color: #2c3e50;
            }

            form {
                margin-bottom: 20px;
            }

            input[type="text"] {
                padding: 10px;
                border: 1px solid #bdc3c7;
                border-radius: 5px;
                margin-right: 10px;
                width: 200px;
            }

            button {
                padding: 10px 20px;
                background-color: #3498db;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s ease;
                width: 150px; /* Î≤ÑÌäº ÎÑàÎπÑÎ•º Í∑†ÏùºÌïòÍ≤å ÏÑ§Ï†ï */
                box-sizing: border-box; /* Ìå®Îî©Í≥º Î≥¥ÎçîÎ•º ÎÑàÎπÑÏóê Ìè¨Ìï® */
            }

            button:hover {
                background-color: #2980b9;
            }

            #animalContainer {
                display: none;
                flex-direction: column;
                align-items: center;
            }

            .user-container {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
            }

            .user-counter {
                margin-bottom: 10px;
                font-size: x-large;
                font-weight: bolder;
                color: #2c3e50;
            }

            .user-box {
                border: 1px solid #bdc3c7;
                border-radius: 50px;
                margin: 8px;
                padding: 8px;
                width: 220px;
                text-align: center;
                background-color: white;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }

            .animal-image {
                width: 180px;
                height: 180px;
            }

            .expression-buttons,
            .mic-button {
                margin-top: 20px;
            }

            .expression-buttons button,
            .mic-button button {
                margin: 5px;
            }

            .mic-button {
                display: flex;
                justify-content: center;
            }

            .mic-status {
                margin-top: 8px;
                margin-bottom: 8px;
            }

            .mic-status img {
                width: 24px;
                height: 24px;
                vertical-align: middle;
            }

            .name-box {
                margin-top: 8px;
                margin-bottom: 8px;
            }
        </style>
    </head>
    <body>
        <h1>Animon</h1>
        <form id="nameForm">
            <input
                type="text"
                id="userName"
                placeholder="Enter Your Name"
                required />
            <button type="submit">Join</button>
        </form>
        <form id="roomForm" style="display: none">
            <input
                type="text"
                id="roomCode"
                placeholder="Enter Room Code"
                required />
            <button type="submit">Join Room</button>
        </form>
        <div id="animalContainer">
            <div id="userCounter" class="user-counter">1 / 5</div>
            <div id="userContainer" class="user-container"></div>
            <div class="expression-buttons">
                <button onclick="changeExpression('happy')">üòä Happy</button>
                <button onclick="changeExpression('sad')">üò¢ Sad</button>
                <button onclick="changeExpression('surprised')">
                    üò≤ Surprised
                </button>
            </div>
            <div class="mic-button">
                <button onclick="toggleMic()">üé§ Toggle Mic</button>
            </div>
        </div>

        <script src="/socket.io/socket.io.js"></script>
        <script>
            const socket = io();

            const nameForm = document.getElementById("nameForm");
            const roomForm = document.getElementById("roomForm");
            const animalContainer = document.getElementById("animalContainer");
            const userContainer = document.getElementById("userContainer");
            const userCounter = document.getElementById("userCounter");

            let isMicOn = false;
            let roomCode = null;
            let userName = "";
            let timeoutId = null;
            let localStream = null;
            let onFrameId = null;
            let onFrame;
            let userCount = 0;

            const peerConnections = {};
            const config = {
                iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
            };

            nameForm.addEventListener("submit", (e) => {
                e.preventDefault();
                userName = document.getElementById("userName").value;
                nameForm.style.display = "none";
                roomForm.style.display = "block";
            });

            roomForm.addEventListener("submit", (e) => {
                e.preventDefault();
                roomCode = document.getElementById("roomCode").value;
                tryJoinRoom(roomCode);
            });

            function tryJoinRoom(roomCode) {
                socket.emit("tryJoin", roomCode);
            }

            socket.on("roomFull", () => {
                alert("Room is full!");
            });

            socket.on("joinOK", (roomCode) => {
                joinRoom(roomCode);
            });

            async function joinRoom(roomCode) {
                console.log("Accessing media...");
                // ÎßàÏù¥ÌÅ¨ Ïä§Ìä∏Î¶º ÏÑ§Ï†ï
                await navigator.mediaDevices
                    .getUserMedia({ audio: true })
                    .then((stream) => {
                        localStream = stream; // Î°úÏª¨ Ïä§Ìä∏Î¶º Ï†ÄÏû•
                        console.log("Local stream obtained");

                        // Ìä∏Îûô ÎπÑÌôúÏÑ±Ìôî
                        localStream.getAudioTracks().forEach((track) => {
                            track.enabled = false;
                        });

                        // ÎßàÏù¥ÌÅ¨ Ïù∏Ìíã Ï∏°Ï†ï
                        const context = new AudioContext();
                        const analyzer = context.createAnalyser();
                        const mediaStreamAudioStreamSource =
                            context.createMediaStreamSource(stream);
                        mediaStreamAudioStreamSource.connect(analyzer, 0);
                        const pcmData = new Float32Array(analyzer.fftSize);

                        // register anim
                        onFrame = () => {
                            analyzer.getFloatTimeDomainData(pcmData);
                            let sum = 0.0;
                            for (const amplitude of pcmData) {
                                sum += amplitude * amplitude;
                            }
                            const rms = Math.sqrt(sum / pcmData.length);
                            const normalizedVolume = Math.min(1, rms / 0.5);
                            changeVolumeColor(normalizedVolume * 10);
                            onFrameId = window.requestAnimationFrame(onFrame);
                        };

                        onFrameId = window.requestAnimationFrame(onFrame);
                    })
                    .catch((error) => {
                        console.error("Error accessing media devices.", error);
                    });

                //Î£∏ Ï°∞Ïù∏
                socket.emit("joinRoom", { roomCode, userName });
                roomForm.style.display = "none";
                animalContainer.style.display = "flex";

                socket.off("existingUsers");
                socket.off("userJoined");
                socket.off("userLeft");
                socket.off("changeExpression");
                socket.off("toggleMic");
                socket.off("offer");
                socket.off("answer");
                socket.off("candidate");

                console.log("My socket id : " + socket.id);

                socket.on("existingUsers", (users) => {
                    users.forEach((user) => {
                        addUser(user.userId, user.userName, user.isMicOn);
                        userCount++;
                    });
                    userCounter.innerText = userCount + " / 5";
                });

                socket.on("userJoined", (data) => {
                    if (data.userId == socket.id) {
                        console.log("user join conflict!");
                        return;
                    }

                    addUser(data.userId, data.userName, data.isMicOn);
                    createOffer(data.userId);

                    userCount++;
                    userCounter.innerText = userCount + " / 5";
                });

                socket.on("userLeft", (data) => {
                    removeUser(data.userId);
                    closePeerConnection(data.userId);

                    userCount--;
                    userCounter.innerText = userCount + " / 5";
                });

                socket.on("changeExpression", (data) => {
                    updateExpression(data);
                });

                socket.on("toggleMic", (data) => {
                    const userBox = document.getElementById(data.userId);
                    if (userBox) {
                        const micStatus = userBox.querySelector(".mic-status");
                        micStatus.innerHTML = `<img src="${
                            data.isMicOn ? "mic_on.png" : "mic_off.png"
                        }" alt="Mic Status">`;
                    }
                    console.log(
                        `Mic for user ${data.userId} is ${
                            data.isMicOn ? "on" : "off"
                        }`
                    );
                });

                socket.on("offer", (data) => {
                    console.log("Recieve offer from.." + data.from);
                    createAnswer(data);
                });

                socket.on("answer", (data) => {
                    console.log("Recieve answer from.." + data.from);
                    if (peerConnections[data.from]) {
                        if (data.from == socket.id) {
                            console.log("Anwser self conflict!");
                            return;
                        }

                        peerConnections[data.from]
                            .setRemoteDescription(
                                new RTCSessionDescription(data.answer)
                            )
                            .catch((error) => {
                                console.error(
                                    "Error setting remote description for answer: ",
                                    error
                                );
                            });

                        console.log(
                            "Registering answer => from : " +
                                data.from +
                                " to : "
                        );
                        console.log(data.answer);
                    }
                });

                socket.on("candidate", (data) => {
                    const candidate = new RTCIceCandidate(data.candidate);
                    if (peerConnections[data.from]) {
                        console.log(
                            "Got candidate from " +
                                data.from +
                                " ... Registering."
                        );
                        peerConnections[data.from].addIceCandidate(candidate);
                    }
                });
            }

            function changeVolumeColor(vol) {
                //console.log("Changing volume color base on => " + vol);

                const VOL_METER_MAX = 10;
                const user_box = document.getElementById(socket.id);
                const normal_number = normalizeToInteger(vol, 0, VOL_METER_MAX);

                if (user_box) {
                    if (normal_number > 1)
                        user_box.style.boxShadow =
                            "0 0px 16px rgba(51, 204, 51, 1)";
                    else
                        user_box.style.boxShadow =
                            "0 4px 8px rgba(0, 0, 0, 0.1)";
                }
            }

            function normalizeToInteger(volume, min, max) {
                const scaledValue = Math.min(
                    max,
                    Math.max(min, volume * (max - min) + min)
                );
                return Math.round(scaledValue);
            }

            function addUser(userId, name, micStatus) {
                if (document.getElementById(userId)) return;

                const userBox = document.createElement("div");
                userBox.id = userId;
                userBox.className = "user-box";
                userBox.innerHTML = `
                <img src="neutral_animal.png" alt="Animal Character" class="animal-image">
                <p class="name-box">${name}</p>
                <p class="mic-status"><img src="${
                    micStatus ? "mic_on.png" : "mic_off.png"
                }" alt="Mic Status"></p>
                <audio id="audio-${userId}" autoplay></audio>
            `;
                userContainer.appendChild(userBox);
            }

            function removeUser(userId) {
                const userBox = document.getElementById(userId);
                if (userBox) {
                    userContainer.removeChild(userBox);
                }
                closePeerConnection(userId);
            }

            function changeExpression(expression) {
                socket.emit("changeExpression", {
                    roomCode,
                    expression,
                    userId: socket.id,
                });

                if (timeoutId) {
                    clearTimeout(timeoutId);
                }

                timeoutId = setTimeout(() => {
                    socket.emit("changeExpression", {
                        roomCode,
                        expression: "neutral",
                        userId: socket.id,
                    });
                }, 2000);
            }

            function updateExpression(data) {
                const userBox = document.getElementById(data.userId);
                if (userBox) {
                    const animalImage = userBox.querySelector(".animal-image");
                    switch (data.expression) {
                        case "happy":
                            animalImage.src = "happy_animal.png";
                            break;
                        case "sad":
                            animalImage.src = "sad_animal.png";
                            break;
                        case "surprised":
                            animalImage.src = "surprised_animal.png";
                            break;
                        case "neutral":
                            animalImage.src = "neutral_animal.png";
                            break;
                    }
                }
            }

            function toggleMic() {
                isMicOn = !isMicOn;
                socket.emit("toggleMic", {
                    roomCode,
                    isMicOn,
                    userId: socket.id,
                });

                const userBox = document.getElementById(socket.id);
                if (userBox) {
                    const micStatus = userBox.querySelector(".mic-status");
                    micStatus.innerHTML = `<img src="${
                        isMicOn ? "mic_on.png" : "mic_off.png"
                    }" alt="Mic Status">`;
                }

                console.log("Mic is " + (isMicOn ? "on" : "off"));

                // Enable or disable the audio tracks
                if (localStream) {
                    localStream.getAudioTracks().forEach((track) => {
                        track.enabled = isMicOn;
                    });

                    if (isMicOn) {
                        onFrameId = window.requestAnimationFrame(onFrame);
                    } else {
                        if (onFrameId) window.cancelAnimationFrame(onFrameId);
                    }
                } else {
                    console.error("No local stream available to toggle.");
                }
            }

            function createOffer(userId) {
                console.log("Creating... Offer...");

                const peerConnection = new RTCPeerConnection(config);
                peerConnections[userId] = peerConnection;

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log(
                            "offer emiting candiate to (" +
                                socket.id +
                                ") - " +
                                event.candidate
                        );
                        socket.emit("candidate", {
                            to: userId,
                            from: socket.id,
                            candidate: event.candidate,
                        });
                    }
                };

                peerConnection.ontrack = (event) => {
                    const audio = document.querySelector(`#audio-${userId}`);
                    if (audio.srcObject !== event.streams[0]) {
                        audio.srcObject = event.streams[0];
                        console.log(
                            "audio player registered : " +
                                audio +
                                " / " +
                                event.streams[0]
                        );
                    }
                };

                if (localStream) {
                    localStream.getTracks().forEach((track) => {
                        peerConnection.addTrack(track, localStream);
                    });
                }

                peerConnection
                    .createOffer()
                    .then((offer) => peerConnection.setLocalDescription(offer))
                    .then(() => {
                        socket.emit("offer", {
                            to: userId,
                            from: socket.id,
                            offer: peerConnection.localDescription,
                        });
                    })
                    .catch((error) => {
                        console.error("Error creating offer: ", error);
                    });
            }

            function createAnswer(data) {
                console.log("Creating... Answer...");

                const peerConnection = new RTCPeerConnection(config);
                peerConnections[data.from] = peerConnection;

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log("Answer ice candidate : ");
                        console.log(event.candidate);
                        socket.emit("candidate", {
                            to: data.from,
                            from: socket.id,
                            candidate: event.candidate,
                        });
                    }
                };

                peerConnection.ontrack = (event) => {
                    const audio = document.querySelector(`#audio-${data.from}`);
                    if (audio.srcObject !== event.streams[0]) {
                        audio.srcObject = event.streams[0];
                    }
                };

                peerConnection
                    .setRemoteDescription(new RTCSessionDescription(data.offer))
                    .then(() => {
                        console.log("Remote description set.");
                        if (localStream) {
                            localStream.getTracks().forEach((track) => {
                                peerConnection.addTrack(track, localStream);
                            });
                        }
                        return peerConnection.createAnswer();
                    })
                    .then((answer) =>
                        peerConnection.setLocalDescription(answer)
                    )
                    .then(() => {
                        socket.emit("answer", {
                            to: data.from,
                            from: socket.id,
                            answer: peerConnection.localDescription,
                        });
                    })
                    .catch((error) => {
                        console.error("Error creating answer: ", error);
                    });
            }

            function closePeerConnection(userId) {
                if (peerConnections[userId]) {
                    peerConnections[userId].close();
                    delete peerConnections[userId];
                }
            }
        </script>
    </body>
</html>
